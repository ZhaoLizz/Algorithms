# 散列表
* 如果所有的键都是小整数,可以用一个数组实现无序的符号表
    * **将键转化为数组的索引**,数组中键i处存储的就是它对应的值
* 散列查找的步骤
    * 1. 用**散列函数**将被查找的键转化为数组的一个索引 
    * 2. 处理**碰撞冲突**,包括拉链法和线性探测法

## 散列函数
* 将键转化为数组的索引,要求能够均匀分布所有的键
* 散列函数和键的类型有关,对于每种类型的键我们都需要一个与之对应的散列函数

1. **正整数**
    * **除留余数法**:选择大小为素数`M`的数组,对于任意`正整数k`,计算` k 除以 M 的余数 (k%M)`,可以有效地将键散布在`0到M-1的范围内`
2. **浮点数**
    * 如果键是`0到1之间的实数`,可以将它**乘 M 并四舍五入得到一个 0 至M-1之间的索引值**
    * 这个办法在四舍五入时有误差缺陷,因为低位数低的作用比高位小,解决方法**是将键表示为二进制后再使用除留余数法**

3. **字符串**
    * 仍然用**除留余数法**,把字符串当做大整数即可

```java
R是进制位数,M是散列在大小为M的数组
        int hash = 0;
        String s;
        for (int i = 0; i < s.length(); i++) {
            hash = (R * hash + s.charAt(i)) % M;
        }
```

4. **组合键**
    * 例如Date年月日 含有多个整型变量,可以像String类型一样将它们混合起来
    `int hash = (((day * R + month) % M) * R + year) % M;`

#### java的约定
* 每种数据类型都继承了hashCode方法,**每一种数据类型的hashCode()方法必须和equals()方法一致**
    * 如果a.euuals(b),呢么a,b的hashCode值必然相等
* 但是如果两个对象的`hashCode()`值相同,对象却有可能不同,还需要用`equals()`方法来判断

## 基于拉链法的散列表
* 将大小为M的数组中的每个元素指向一条链表,链表中的每个结点都存储了`散列值为该元素的索引的`键值对,发生冲突的元素都被存储在链表中
    * Key对应的散列值即为key在**链表数组**中的下标
* 基本思想是 选择足够大的M,使得所有链表都尽可能短以保证高效的查找

```java
/**
 * 基于拉链法的散列表
 */
public class SeparateChainingHashST<Key, Value> {
    private int N;  //键值对总数
    private int M;  //散列表的大小
    //存放 链表数组 的实例对象
    private SequentialSearchST<Key, Value>[] st;

    public SeparateChainingHashST(int M) {
        this.M = M;
        //java不允许泛型数组,所以在这里进行类型转换
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M];
        for (int i = 0; i < M; i++) {
            st[i] = new SequentialSearchST<>();
        }
    }

    /**
     * 获取key的哈希散列值,散列值即为Key在链表数组中的下标
     * 用散列函数来为每一个键选择一条链表
     *
     * @param key
     * @return
     */
    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }

    public Value get(Key key) {
        //先从链表数组中获取下标为key的散列值的这条链表,然后调用链表的get方法获取Key的Value
        return st[hash(key)].get(key);
    }

    public void put(Key key, Value val) {
        st[hash(key)].put(key, val);
    }

    public void delete(Key key) {
        st[hash(key)].delete(key);
    }
}

```