# 哈弗曼树(最优二叉树)

## 基本概念
* 结点之间的路径长度: 从一个结点到另一个结点**所经过的分支数**(注意是**经过**,不包括自身结点,包括最终的到达结点)
* 树的路径长度: 从树的根节点到树中每一个结点的**路径长度之和**.
    * 在结点数目相同的二叉树中,完全二叉树的路径长度最短
* 结点的权:给结点赋予一个有意义的实数
* 结点的带权路径长度: 该结点到根节点之间**路径长度 与 该结点上权的乘积**
* 树的带权路径长度: 树中所有**叶子节点**的带权路径长度之和

## 最优二叉树的构建
* 依次选取**权值最小的结点**放在树的底部,将两个最小的连接构成一个新节点,**新节点的权值是这两个结点的权值之和**,然后把这个新节点放回我们需要构成树的结点中继续排序,直到构成一棵树
* 最优二叉树中,**权越大的叶子离根越近**
* 最优二叉树形态不唯一,WPL最小

## 哈弗曼编码
* 假设需要把一个字符串*如"abcdabcaba"*进行编码,将它转化为唯一的**二进制码**,要求**转换出的二进制码的长度最小**
* 假设每个字符在字符串在字符串中出现的频率为W,其编码长度为L,编码字符n个,则编码后的二进制码的总长度为`W1L1 + W2L2 + ... + WnLn`.因此可采用哈夫曼树的构造原理进行二进制编码,从而使得电文长度最短
* **构建过程**: 将**字符在字符串中出现的次数**作为权值,构建好一棵完整的哈夫曼树之后,从**根节点**开始,对左子树分配代码0,对右子树分配1,一直到达叶子节点.然后将**从树根沿着每条路径到达叶子节点的代码排列起来**,便得到每个叶子节点的哈弗曼编码

![哈弗曼编码](http://img.blog.csdn.net/20140818101843502)

