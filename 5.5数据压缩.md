# 数据压缩

## 1.游程编码
* 常用于压缩**一长串重复的比特**
* 例: `0000000000000001111111000000011111111111`   
    * 这段数据含有15个0,7个1,7个0,11个1,因此将该**交替出现的0和1比特字符串**编码为15,7,7,11
    * 然后把编码转化为**二进制形式**,(15=1111,7=0111,7=0111,11=1011)连接在一起: `1111011101111011`
* 游程的长度应该在`0-255`之间,**使用8位编码**
* 当某个游程的长度超过了能记录的最大长度时,应该使用长度为0的游程来保证所有游程的长度均小于256

```java
package com.company.string;

import edu.princeton.cs.algs4.BinaryStdIn;
import edu.princeton.cs.algs4.BinaryStdOut;

public class RunLength {
    public static void expand() {
        boolean b = false;

        while (!BinaryStdIn.isEmpty()) {
            //读取8位比特(读取一个游程长度)并转化为一个char字符
            char cnt = BinaryStdIn.readChar();
            //将当前比特按照长度复制并打印
            for (int i = 0; i < cnt; i++) {
                BinaryStdOut.write(b);
            }
            //转换当前比特,然后进入下一轮循环读取下一位游程
            b = !b;
        }

        BinaryStdOut.close();
    }

    public static void compress() {
        char cnt = 0;
        boolean b, old = false;

        while (!BinaryStdIn.isEmpty()) {
            //读取一个比特,如果这个比特和上一个比特不同,
            //写入当前的计数值并将计数器归零
            b = BinaryStdIn.readBoolean();
            if (b != old) {
                BinaryStdOut.write(cnt);
                cnt = 0;
                old = !old;
            } else {
                //如果这个比特和上一个比特相同,但是cnt已经写满
                if (cnt == 255) {
                    BinaryStdOut.write(cnt);
                    cnt = 0;
                    //这里使用一个长度为0的游程来保证所有游程的长度均小于256
                    BinaryStdOut.write(cnt);
                }
            }
            //这个比特和上一个比特相同,cnt未满的情况
            cnt++;
        }
        BinaryStdOut.write(cnt);
        BinaryStdOut.close();
    }
}
```


## 霍夫曼压缩

#### 霍夫曼树基本概念
* 结点之间的路径长度: 从一个结点到另一个结点**所经过的分支数**(注意是**经过**,不包括自身结点,包括最终的到达结点)
* 树的路径长度: 从树的根节点到树中每一个结点的**路径长度之和**.
    * 在结点数目相同的二叉树中,完全二叉树的路径长度最短
* 结点的权:给结点赋予一个有意义的实数
* 结点的带权路径长度: 该结点到根节点之间**路径长度 与 该结点上权的乘积**
* 树的带权路径长度: 树中所有**叶子节点**的带权路径长度之和

#### 最优二叉树的构建
* 依次选取**权值最小的结点**放在树的底部,将两个最小的连接构成一个新节点,**新节点的权值是这两个结点的权值之和**,然后把这个新节点放回我们需要构成树的结点中继续排序,直到构成一棵树
* 最优二叉树中,**权越大的叶子离根越近**
* 最优二叉树形态不唯一,WPL最小

#### 霍夫曼编码
* 基本思想:用较少的比特表示出现频率高的字符,用较多的比特表示出现频率低的字符
* 假设需要把一个字符串*如"abcdabcaba"*进行编码,将它转化为唯一的**二进制码**,要求**转换出的二进制码的长度最小**
* 假设每个字符在字符串在字符串中出现的**频率**为W,其编码长度为L,编码字符n个,则编码后的二进制码的总长度为`W1L1 + W2L2 + ... + WnLn`.因此可采用哈夫曼树的构造原理进行二进制编码,从而使得电文长度最短
* **构建过程**: 将**字符在字符串中出现的次数**作为权值,构建好一棵完整的哈夫曼树之后,从**根节点**开始,对左子树分配代码0,对右子树分配1,一直到达叶子节点.然后将**从树根沿着每条路径到达叶子节点的代码排列起来**,便得到每个叶子节点的哈弗曼编码.然后把每个字符编码连接起来就得到对应的字符串的二进制编码

![哈弗曼编码](http://img.blog.csdn.net/20140818101843502)


#### 实现
* **压缩过程**
1. 读取输入
1. 将输入中的每个char值得出现频率制成`int[] freq`数组
1. 根据频率构造相应的霍夫曼编码树
1. 构造编译表,将输入中的**每个char值和一个比特字符串**相关联
1. 将单词查找树编码为比特字符串并写入输出流
1. 将单词总数编码为比特字符串并写入输出流
1. 使用编译表翻译每个输入字符
* **展开过程**
1. 读取单词查找树(编码在比特流的开头) 
1. 读取需要解码的字符数量
1. 使用单词查找树将比特流解码